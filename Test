/// <summary>Central helper that tells whether a point belongs to Input / Logic / Output.</summary>
internal static class LogicAreaClassifier
{
    // NOTE: target-typed “new()” is C# 9 — use the full generic form:
    private static readonly HashSet<string> _input =
        new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        { "Symbol:AI", "Symbol:DI", ".eVT_AI", ".eVT_DI" /* extend as required */ };

    private static readonly HashSet<string> _output =
        new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        { "Symbol:AO", "Symbol:DO", ".eVT_AO", ".eVT_DO" /* extend as required */ };

    internal static string GetAreaFor(string logicType)
    {
        // C# 7.3 / .NET 4.8 has no string.Contains 2-arg overload; fall back to IndexOf.
        if (_input.Any(t => logicType?.IndexOf(t, StringComparison.OrdinalIgnoreCase) >= 0))
            return SMConstants.InputArea;

        if (_output.Any(t => logicType?.IndexOf(t, StringComparison.OrdinalIgnoreCase) >= 0))
            return SMConstants.OutputArea;

        return SMConstants.LogicArea;
    }
}

private readonly Dictionary<string, string> _areaIds = new Dictionary<string, string>();

private void PersistVirtualAreas()
{
    // C# 7 interpolated strings are fine.
    string inputId  = $"{ControllerName}.{SMConstants.InputArea}";
    string logicId  = $"{ControllerName}.{SMConstants.LogicArea}";
    string outputId = $"{ControllerName}.{SMConstants.OutputArea}";

    _areaIds[SMConstants.InputArea]  = inputId;
    _areaIds[SMConstants.LogicArea]  = logicId;
    _areaIds[SMConstants.OutputArea] = outputId;

    var virtualPoints = new[]
    {
        new SMLogicalPointInfo(
                logicPointFullName : SMConstants.InputArea,
                logicPoinShorttName: SMConstants.InputArea,
                logicTypeInfo      : SMConstants.InputArea,
                logicPointID       : inputId,
                executionContainer : ControllerName,
                isTag              : true,
                description        : SMConstants.InputArea,
                navigation_ID      : null),

        new SMLogicalPointInfo(
                SMConstants.LogicArea, SMConstants.LogicArea,
                SMConstants.LogicArea, logicId, ControllerName,
                true, SMConstants.LogicArea, null),

        new SMLogicalPointInfo(
                SMConstants.OutputArea, SMConstants.OutputArea,
                SMConstants.OutputArea, outputId, ControllerName,
                true, SMConstants.OutputArea, null),
    };

    // Push the stubs to the same list used for “real” points,
    // then emit them through the normal AddLogicalPoint pipeline.
    ListSMLogicalPointInfo.AddRange(virtualPoints);

    foreach (var vp in virtualPoints)
        AddLogicalPoint(vp);          // writes <LogicalPoint/>
}
